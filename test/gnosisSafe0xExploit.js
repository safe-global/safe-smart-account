const utils = require('./utils/general')
const safeUtils = require('./utils/execution')
const abi = require('ethereumjs-abi')


const GnosisSafe = artifacts.require("./GnosisSafe.sol")
const ProxyFactory = artifacts.require("./ProxyFactory.sol")

contract('GnosisSafe 0x EIP-1271 exploit', function(accounts) {

    let lw
    let ownerSafe
    let gnosisSafe
    let executor = accounts[8]

    const CALL = 0

    beforeEach(async function () {
        // Create lightwallet
        lw = await utils.createLightwallet()
        // Create Master Copies
        let proxyFactory = await ProxyFactory.new()
        let gnosisSafeMasterCopy = await utils.deployContract("deploying Gnosis Safe Mastercopy", GnosisSafe)
        // Create Gnosis Safe
        let ownerSafeData = await gnosisSafeMasterCopy.contract.setup.getData([lw.accounts[0], lw.accounts[1]], 2, 0, "0x", 0, 0, 0, 0)
        ownerSafe = utils.getParamFromTxEvent(
            await proxyFactory.createProxy(gnosisSafeMasterCopy.address, ownerSafeData),
            'ProxyCreation', 'proxy', proxyFactory.address, GnosisSafe, 'create Gnosis Safe Proxy',
        )
        let gnosisSafeData = await gnosisSafeMasterCopy.contract.setup.getData([ownerSafe.address, accounts[2]], 1, 0, "0x", 0, 0, 0, 0)
        gnosisSafe = utils.getParamFromTxEvent(
            await proxyFactory.createProxy(gnosisSafeMasterCopy.address, gnosisSafeData),
            'ProxyCreation', 'proxy', proxyFactory.address, GnosisSafe, 'create Gnosis Safe Proxy',
        )
    })

    /*
     * In case of 0x it was possible to use EIP-1271 (contract signatures) to generate a valid signature for EOA accounts.
     * See https://samczsun.com/the-0x-vulnerability-explained/
     */
    it('should not be able to use EIP-1271 (contract signatures) for EOA', async () => {
        // Deposit 1 ETH + some spare money for execution 
        assert.equal(await web3.eth.getBalance(gnosisSafe.address), 0)
        await web3.eth.sendTransaction({from: accounts[0], to: gnosisSafe.address, value: web3.toWei(1, 'ether')})
        assert.equal(await web3.eth.getBalance(gnosisSafe.address).toNumber(), web3.toWei(1, 'ether'))

        let operation = 0
        let to = accounts[0]
        let value = web3.toWei(1, 'ether')
        let data = "0x"
        let nonce = await gnosisSafe.nonce()

        // Use off-chain Safe signature
        let messageData = await gnosisSafe.encodeTransactionData(to, value, data, operation, 0, 0, 0, 0, 0, nonce)
        let messageHash = await ownerSafe.getMessageHash(messageData)
        let ownerSigs = utils.signTransaction(lw, [lw.accounts[0], lw.accounts[1]], messageHash).slice(2)
        let encodedOwnerSigns = abi.rawEncode(['bytes'], [ new Buffer(ownerSigs, 'hex') ]).toString('hex').slice(64)

        // Use EOA owner
        let sigs = "0x" +
            "000000000000000000000000" + accounts[2] + 
            "0000000000000000000000000000000000000000000000000000000000000041" + 
            "00" + // r, s, v
            encodedOwnerSigns 

        // Transaction should fail (invalid signatures should revert the Ethereum transaction)
        await utils.assertRejects(
            gnosisSafe.execTransaction(to, value, data, operation, 0, 0, 0, 0, 0, sigs, {from: executor}),
            "Transaction should fail if invalid signature is provided"
        );
        assert.equal(await web3.eth.getBalance(gnosisSafe.address), web3.toWei(1, 'ether'))

        // Use Safe owner
        sigs = "0x" +
            "000000000000000000000000" + ownerSafe.address.replace('0x', '') + 
            "0000000000000000000000000000000000000000000000000000000000000041" + 
            "00" + // r, s, v
            encodedOwnerSigns 
        let tx = await gnosisSafe.execTransaction(to, value, data, operation, 0, 0, 0, 0, 0, sigs, {from: executor})
        utils.logGasUsage("execTransaction with EIP-1271 (contract signatures)", tx)

        // Safe should be empty again
        assert.equal(await web3.eth.getBalance(gnosisSafe.address), 0)
    })

    it('should revert if EIP-1271 check changes state', async () => {
        // Test Validator
        let source = `
        contract Test {
            bool public changeState;
            uint256 public nonce;
            function isValidSignature(bytes memory _data, bytes memory _signature) public returns (bytes4) {
                if (changeState) {
                    nonce = nonce + 1;
                }
                return 0x20c13b0b;
            }

            function shouldChangeState(bool value) public {
                changeState = value;
            }
        }`
        let testValidator = await safeUtils.deployContract(accounts[0], source);
        await testValidator.shouldChangeState(true, {from: accounts[0]})
        // Add validator
        let addData = await gnosisSafe.contract.addOwnerWithThreshold.getData(testValidator.address, 1)
        let addSigs = "0x" + 
            "000000000000000000000000" + accounts[2].replace('0x', '') +
            "0000000000000000000000000000000000000000000000000000000000000000" + 
            "01"
        await gnosisSafe.execTransaction(gnosisSafe.address, 0, addData, 0, 0, 0, 0, 0, 0, addSigs, {from: accounts[2]})
        assert.deepEqual(await gnosisSafe.getOwners(), [testValidator.address, ownerSafe.address, accounts[2]])

        // Deposit 1 ETH + some spare money for execution 
        assert.equal(await web3.eth.getBalance(gnosisSafe.address), 0)
        await web3.eth.sendTransaction({from: accounts[0], to: gnosisSafe.address, value: web3.toWei(1, 'ether')})
        assert.equal(await web3.eth.getBalance(gnosisSafe.address).toNumber(), web3.toWei(1, 'ether'))

        let operation = 0
        let to = accounts[0]
        let value = web3.toWei(1, 'ether')
        let data = "0x"
        let nonce = await gnosisSafe.nonce()

        // Use off-chain Safe signature
        let messageData = await gnosisSafe.encodeTransactionData(to, value, data, operation, 0, 0, 0, 0, 0, nonce)
        let messageHash = await ownerSafe.getMessageHash(messageData)
        let ownerSigs = utils.signTransaction(lw, [lw.accounts[0], lw.accounts[1]], messageHash).slice(2)
        let encodedOwnerSigns = abi.rawEncode(['bytes'], [ new Buffer(ownerSigs, 'hex') ]).toString('hex').slice(64)

        // Use Safe owner
        let sigs = "0x" +
            "000000000000000000000000" + testValidator.address.replace('0x', '') + 
            "0000000000000000000000000000000000000000000000000000000000000041" + 
            "00" + // r, s, v
            encodedOwnerSigns 

        // Transaction should fail (state changing signature check should revert)
        await utils.assertRejects(
            gnosisSafe.execTransaction(to, value, data, operation, 0, 0, 0, 0, 0, sigs, {from: executor}),
            "Transaction should fail if signature check changes state"
        );
        assert.equal(await web3.eth.getBalance(gnosisSafe.address), web3.toWei(1, 'ether'))

        await testValidator.shouldChangeState(false, {from: accounts[0]})
        let tx = await gnosisSafe.execTransaction(to, value, data, operation, 0, 0, 0, 0, 0, sigs, {from: executor})
        utils.logGasUsage("execTransaction with EIP-1271 (contract signatures)", tx)

        // Safe should be empty again
        assert.equal(await web3.eth.getBalance(gnosisSafe.address), 0)
    })
})
